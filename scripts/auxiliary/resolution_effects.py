"""Estimate resolution effects on cool gas fraction and mass."""
from __future__ import annotations

import argparse
import logging
import sys
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import yaml

root_dir = Path(__file__).parents[2].resolve()
sys.path.insert(0, str(root_dir / "src"))

from library import constants, scriptparse
from library.config import config
from library.data_acquisition import halos_daq
from library.processing import selection


def main(args: argparse.Namespace) -> None:
    """
    Plot comparison of cool gas mass and fraction at different resolution.

    :param args: Namespace object, generated by argparser.
    :return: None.
    """
    logging.info("Starting script to plot resolution effects plot."
                 "")
    # Step 0: find data directory and base paths
    root_dir = Path(__file__).parents[2].resolve()
    if not (root_dir / "config.yaml").exists():
        raise config.MissingConfigFileError()
    with open(root_dir / "config.yaml", "r") as config_file:
        stream = config_file.read()
    cfg = yaml.full_load(stream)
    cfg_obj = config.get_default_config("TNG300-1")
    data_home = cfg_obj.data_home
    figures_home = cfg_obj.figures_home

    # Step 1: prepare figure
    logging.info("Preparing figure.")
    fig, axes = plt.subplots(ncols=2, figsize=(10, 5))
    for ax in axes:
        ax.set_xlabel(r"Halo mass [$M_\odot$]")
        ax.set_xscale("log")
    axes[0].set_ylabel("Cool gas mass fraction")
    axes[1].set_ylabel(r"Cool gas mass [$M_\odot$]")
    axes[1].set_yscale("log")

    # Step 2: go through the simulations and load their data
    resolution_mapping = {
        "TNG300-2": {
            "marker": "d", "color": "blue"
        },
        "TNG300-1": {
            "marker": "o", "color": "black"
        },
        "TNG100-1": {
            "marker": "^", "color": "purple"
        },
    }
    logging.info("Starting process of going through resolutions.")
    for sim, plot_config in resolution_mapping.items():
        logging.info(f"Processing simulation {sim}.")
        # Step 1: load halo masses
        base_path = cfg["paths"]["base_paths"][sim]
        halo_data = halos_daq.get_halo_properties(
            base_path, 99, fields=["Group_M_Crit200"]
        )
        cluster_data = selection.select_clusters(
            halo_data,
            "Group_M_Crit200",
            expected_number=constants.N_CLUSTERS[sim],
        )
        del halo_data

        # Step 2: allocate memory for cool gas data
        cool_fractions = np.zeros_like(cluster_data["Group_M_Crit200"])
        cool_masses = np.zeros_like(cool_fractions)

        # Step 3: Go through clusters and save masses and fractions
        sim_path = sim.replace("-", "_")
        gas_mass_dir = data_home / "particle_masses" / sim_path
        temp_flag_dir = data_home / "particle_regimes" / sim_path
        logging.info(f"Going through individual {sim} clusters.")
        for i, halo_id in enumerate(cluster_data["IDs"]):
            logging.debug(f"Processing cluster {halo_id}.")
            mass_file = gas_mass_dir / f"gas_masses_halo_{halo_id}.npy"
            flag_file = (
                temp_flag_dir
                / f"particle_temperature_regimes_halo_{halo_id}.npy"
            )
            gas_masses = np.load(mass_file)
            gas_regime = np.load(flag_file)
            # assign to allocated memory
            cool_masses[i] = np.sum(gas_masses[gas_regime == 1])
            cool_fractions[i] = cool_masses[i] / np.sum(gas_masses)

        # Step 4: plot onto the figure
        logging.info("Plotting data points onto figure.")
        halo_masses = cluster_data["Group_M_Crit200"]
        axes[0].plot(
            halo_masses,
            np.log10(cool_fractions),
            linestyle="none",
            label=sim,
            **plot_config,
        )
        axes[1].plot(
            halo_masses,
            cool_masses,
            linestyle="none",
            label=sim,
            **plot_config
        )

    # Step 3: save the figure to file
    axes[0].legend()
    axes[1].legend()
    filepath = figures_home / f"resolution_effects.{args.fig_ext}"
    fig.savefig(filepath, bbox_inches="tight")
    # close figure
    plt.close(fig)
    logging.info("Successfully saved resolution effects plot to file!")


DESCRIPTION = """Estimate the effects of resolution on cool gas fraction.

Script plots the cool gas mass and cool gas fraction of TNG100-1, TNG300-1,
and TNG300-2 into a two-panel figure. This allows estimating what impact
simulation resolution has on the cool gas fraction and cool gas mass in
simulated clusters.
"""

if __name__ == "__main__":
    # construct parser
    parser = argparse.ArgumentParser(
        prog=f"python {Path(__file__).name}",
        description=DESCRIPTION,
    )
    parser.add_argument(
        "--ext",
        help="File extension for the plot files. Defaults to pdf.",
        dest="fig_ext",
        type=str,
        default="pdf",
        choices=["pdf", "png"]
    )
    exclusion_group = parser.add_mutually_exclusive_group(required=False)
    exclusion_group.add_argument(
        "-v",
        help=(
            "Make the output more verbose. Stackable. Determines the log "
            "level and whether real-time updates are sent to stdout. If "
            "not set, the logging level is set to INFO. Setting -v means "
            "log level MEMORY for diagnostics, -vv means real-time status "
            "updates in loops are logged (not recommended when piping "
            "stdout to file!), and -vvv means log level DEBUG."
        ),
        dest="verbosity",
        action="count",
        default=0,
    )
    exclusion_group.add_argument(
        "-q",
        help=(
            "Reduce the verbosity of the script. Stackable. Corresponds to "
            "raising the logging level. Setting -q means log level "
            "WARNING, -qq means log level ERROR, and -qqq means log level "
            "CRITICAL."
        ),
        dest="quiet",
        action="count",
        default=0,
    )

    # parse arguments
    try:
        args_ = parser.parse_args()
        scriptparse.set_up_logging(args_)
        main(args_)
    except KeyboardInterrupt:
        print("Execution forcefully stopped.")
        sys.exit(1)

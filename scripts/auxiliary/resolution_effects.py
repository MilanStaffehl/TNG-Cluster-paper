"""Estimate resolution effects on cool gas fraction and mass."""
from __future__ import annotations

import argparse
import logging
import sys
from pathlib import Path

import matplotlib.patheffects as pe
import matplotlib.pyplot as plt
import numpy as np
import yaml

root_dir = Path(__file__).parents[2].resolve()
sys.path.insert(0, str(root_dir / "src"))

from library import constants, scriptparse
from library.config import config
from library.data_acquisition import halos_daq
from library.processing import selection


def main(args: argparse.Namespace) -> None:
    """
    Plot comparison of cool gas mass and fraction at different resolution.

    :param args: Namespace object, generated by argparser.
    :return: None.
    """
    logging.info("Starting script to plot resolution effects plot."
                 "")
    # Step 0: find data directory and base paths
    root_dir = Path(__file__).parents[2].resolve()
    if not (root_dir / "config.yaml").exists():
        raise config.MissingConfigFileError()
    with open(root_dir / "config.yaml", "r") as config_file:
        stream = config_file.read()
    cfg = yaml.full_load(stream)
    cfg_obj = config.get_default_config("TNG300-1")
    data_home = cfg_obj.data_home
    figures_home = cfg_obj.figures_home

    # Step 1: prepare figure
    limits_frac = (-4.5, -1.5)
    limits_mass = (1e9, 2e12)
    logging.info("Preparing figure.")
    fig, axes = plt.subplots(ncols=2, figsize=(10, 4.5))
    for ax in axes:
        ax.set_xlabel(r"Halo mass [$\log_{10} M_\odot$]")
    axes[0].set_ylabel(r"Cool gas mass fraction [$\log_{10}$]")
    axes[0].set_ylim(limits_frac)
    axes[1].set_ylabel(r"Cool gas mass [$M_\odot$]")
    axes[1].set_ylim(limits_mass)
    axes[1].set_yscale("log")

    # Step 2: go through the simulations and load their data
    resolution_mapping = {
        "TNG300-2":
            {
                "marker": "d", "color": "blue", "res": r"$8.8 \times 10^7$"
            },
        "TNG300-1":
            {
                "marker": "o", "color": "black", "res": r"$1.1 \times 10^7$"
            },
        "TNG100-1":
            {
                "marker": "^", "color": "purple", "res": r"$1.4 \times 10^6$"
            },
    }
    logging.info("Starting process of going through resolutions.")
    for sim, plot_config in resolution_mapping.items():
        logging.info(f"Processing simulation {sim}.")
        # Step 1: load halo masses
        base_path = cfg["paths"]["base_paths"][sim]
        halo_data = halos_daq.get_halo_properties(
            base_path, 99, fields=["Group_M_Crit200"]
        )
        cluster_data = selection.select_clusters(
            halo_data,
            "Group_M_Crit200",
            expected_number=constants.N_CLUSTERS[sim],
        )
        del halo_data

        # Step 2: allocate memory for cool gas data
        cool_fractions = np.zeros_like(cluster_data["Group_M_Crit200"])
        cool_masses = np.zeros_like(cool_fractions)

        # Step 3: Go through clusters and save masses and fractions
        sim_path = sim.replace("-", "_")
        gas_mass_dir = data_home / "particle_masses" / sim_path
        temp_flag_dir = data_home / "particle_regimes" / sim_path
        logging.info(f"Going through individual {sim} clusters.")
        for i, halo_id in enumerate(cluster_data["IDs"]):
            logging.debug(f"Processing cluster {halo_id}.")
            mass_file = gas_mass_dir / f"gas_masses_halo_{halo_id}.npy"
            flag_file = (
                temp_flag_dir
                / f"particle_temperature_regimes_halo_{halo_id}.npy"
            )
            gas_masses = np.load(mass_file)
            gas_regime = np.load(flag_file)
            # assign to allocated memory
            cool_masses[i] = np.sum(gas_masses[gas_regime == 1])
            cool_fractions[i] = cool_masses[i] / np.sum(gas_masses)

        # Step 4: plot onto the figure
        logging.info("Plotting data points onto figure.")
        resolution = plot_config.pop("res")
        halo_masses = cluster_data["Group_M_Crit200"]
        axes[0].plot(
            np.log10(halo_masses),
            np.log10(cool_fractions),
            linestyle="none",
            alpha=0.6,
            label=rf"{sim} ({resolution} $\rm M_\odot$)",
            **plot_config,
        )
        axes[1].plot(
            np.log10(halo_masses),
            cool_masses,
            linestyle="none",
            alpha=0.6,
            label=rf"{sim} ({resolution} $\rm M_\odot$)",
            **plot_config
        )
        # mark values below min
        mark_frac = np.nonzero(np.log10(cool_fractions) <= limits_frac[0])[0]
        mark_mass = np.nonzero(cool_masses <= limits_mass[0])[0]
        arrowstyle = {"arrowstyle": "simple", "color": plot_config["color"]}
        for index in mark_frac:
            x = np.log10(halo_masses[index])
            axes[0].annotate(
                "",
                (x, limits_frac[0] + 0.05),
                (0, 20),  # offset in pt
                textcoords="offset points",
                arrowprops=arrowstyle,
            )
        for index in mark_mass:
            x = np.log10(halo_masses[index])
            axes[1].annotate(
                "",
                (x, limits_mass[0] + 1e8),
                (0, 20),  # offset in pt
                textcoords="offset points",
                arrowprops=arrowstyle,
            )

        # Step 5: Overplot running average
        left_bin_edges = np.linspace(14.0, 15.3, num=14)
        frac_means = np.zeros_like(left_bin_edges, dtype=np.float64)
        mass_means = np.zeros_like(frac_means)
        for i, left_bin_edge in enumerate(left_bin_edges):
            right_bin_edge = left_bin_edge + 0.2
            where = np.logical_and(
                np.log10(halo_masses) >= left_bin_edge,
                np.log10(halo_masses) < right_bin_edge
            )
            frac_means[i] = np.nanmean(cool_fractions[where])
            mass_means[i] = np.nanmean(cool_masses[where])

        # Step 2: overplot running mean
        outline = [pe.Stroke(linewidth=5, foreground="white"), pe.Normal()]
        axes[0].plot(
            left_bin_edges + 0.05,
            np.log10(frac_means),
            linestyle="solid",
            color=plot_config["color"],
            zorder=20,
            lw=2,
            path_effects=outline,
        )
        axes[1].plot(
            left_bin_edges + 0.05,
            mass_means,
            linestyle="solid",
            color=plot_config["color"],
            zorder=20,
            lw=2,
            path_effects=outline,
        )

    # Step 3: save the figure to file
    axes[0].legend(loc="lower right", fontsize=9)
    axes[1].legend(loc="lower right", fontsize=9)
    filepath = figures_home / f"resolution_effects.{args.fig_ext}"
    fig.savefig(filepath, bbox_inches="tight")
    # close figure
    plt.close(fig)
    logging.info("Successfully saved resolution effects plot to file!")


DESCRIPTION = """Estimate the effects of resolution on cool gas fraction.

Script plots the cool gas mass and cool gas fraction of TNG100-1, TNG300-1,
and TNG300-2 into a two-panel figure. This allows estimating what impact
simulation resolution has on the cool gas fraction and cool gas mass in
simulated clusters.
"""

if __name__ == "__main__":
    # construct parser
    parser = argparse.ArgumentParser(
        prog=f"python {Path(__file__).name}",
        description=DESCRIPTION,
    )
    parser.add_argument(
        "--ext",
        help="File extension for the plot files. Defaults to pdf.",
        dest="fig_ext",
        type=str,
        default="pdf",
        choices=["pdf", "png"]
    )
    exclusion_group = parser.add_mutually_exclusive_group(required=False)
    exclusion_group.add_argument(
        "-v",
        help=(
            "Make the output more verbose. Stackable. Determines the log "
            "level and whether real-time updates are sent to stdout. If "
            "not set, the logging level is set to INFO. Setting -v means "
            "log level MEMORY for diagnostics, -vv means real-time status "
            "updates in loops are logged (not recommended when piping "
            "stdout to file!), and -vvv means log level DEBUG."
        ),
        dest="verbosity",
        action="count",
        default=0,
    )
    exclusion_group.add_argument(
        "-q",
        help=(
            "Reduce the verbosity of the script. Stackable. Corresponds to "
            "raising the logging level. Setting -q means log level "
            "WARNING, -qq means log level ERROR, and -qqq means log level "
            "CRITICAL."
        ),
        dest="quiet",
        action="count",
        default=0,
    )

    # parse arguments
    try:
        args_ = parser.parse_args()
        scriptparse.set_up_logging(args_)
        main(args_)
    except KeyboardInterrupt:
        print("Execution forcefully stopped.")
        sys.exit(1)
